clearAll

-- The abstract simplicial complex over `V` generated by
-- `faces`. That is, we expect `faces` to be a subset
-- of the powerset of `V`, and return the smallest simplicial
-- complex containing `faces` according to Definition 5.1.3

simplicialComplex = (V, faces) -> (
	orderedFaces := faces / sort;
	maxSize := max (orderedFaces / length);
	singletons := V / (s -> {s});
	C := {singletons};
	subFaces := unique flatten (orderedFaces / subsets);
	for i in 2..maxSize do(
		C = append(C, select(subFaces, f -> #f == i));
	);
	C
)

indexOf = (l, e) -> (
	i := position(l, x -> x === e);
	if instance(i, Nothing) then -1 else i
);

boundary = (v, C, R) -> (
	img := C_(#v - 2);
	boundaryVec := vector{#img : 0_R};
	sign := 1_R;
	for i in 0..<#v do (
		bv := select(v, e -> (e =!= v_i));
		k := indexOf(img, bv);
		addVec := vector toList join((k):0_R, 1:(sign), (#img - (k + 1)):0_R);
		boundaryVec = boundaryVec + addVec;
		sign = -1_R * sign;
	);
	boundaryVec
)

simplicalComplexMaps = (C, R) -> (
	maps := {};
	for i in 1..<#C do (
		vecs := C_i / (face -> boundary(face, C, R));
		maps = append(maps, matrix(vecs));
	);
	maps
)


V = toList (v_0..v_9)

torus = {
	{v_0,v_5,v_3},
	{v_0,v_1,v_5},
	{v_1,v_5,v_2},
	{v_2,v_6,v_5},
	{v_2,v_0,v_6},
	{v_0,v_6,v_3},
	{v_4,v_3,v_5},
	{v_4,v_5,v_8},
	{v_7,v_5,v_8},
	{v_7,v_5,v_6},
	{v_7,v_9,v_6},
	{v_7,v_8,v_9},
	{v_6,v_9,v_3},
	{v_9,v_4,v_3},
	{v_4,v_0,v_8},
	{v_1,v_0,v_8},
	{v_9,v_1,v_8},
	{v_9,v_1,v_2},
	{v_9,v_0,v_2},
	{v_9,v_0,v_4}
}

torusC = simplicialComplex(V, torus)
torusMapsQQ = simplicalComplexMaps(torusC, QQ)
torusMapsZZ2 = simplicalComplexMaps(torusC, ZZ/2)
ccTorusQQ = chainComplex torusMapsQQ
ccTorusZZ2 = chainComplex torusMapsZZ2
homTorusQQ = prune HH ccTorusQQ
homTorusZZ2 = prune HH ccTorusZZ2

<< "Torus over QQ, rank H_0: " << rank homTorusQQ_0 << endl;
<< "Torus over QQ, rank H_1: " << rank homTorusQQ_1 << endl;
<< "Torus over QQ, rank H_2: " << rank homTorusQQ_2 << endl;

<< "Torus over ZZ/2, rank H_0: " << rank homTorusZZ2_0 << endl;
<< "Torus over ZZ/2, rank H_1: " << rank homTorusZZ2_1 << endl;
<< "Torus over ZZ/2, rank H_2: " << rank homTorusZZ2_2 << endl;


klein = {
	{v_0,v_5,v_3},
	{v_0,v_1,v_5},
	{v_1,v_5,v_2},
	{v_2,v_6,v_5},
	{v_2,v_0,v_6},
	{v_0,v_6,v_4},
	{v_4,v_3,v_5},
	{v_4,v_5,v_8},
	{v_7,v_5,v_8},
	{v_7,v_5,v_6},
	{v_7,v_9,v_6},
	{v_7,v_8,v_9},
	{v_6,v_9,v_4},
	{v_9,v_4,v_3},
	{v_4,v_0,v_8},
	{v_1,v_0,v_8},
	{v_9,v_1,v_8},
	{v_9,v_1,v_2},
	{v_9,v_0,v_2},
	{v_9,v_0,v_3}
}

kleinC = simplicialComplex(V, klein)
kleinMapsQQ = simplicalComplexMaps(kleinC, QQ)
kleinMapsZZ2 = simplicalComplexMaps(kleinC, ZZ/2)
ccKleinQQ = chainComplex kleinMapsQQ
ccKleinZZ2 = chainComplex kleinMapsZZ2
homKleinQQ = prune HH ccKleinQQ
homKleinZZ2 = prune HH ccKleinZZ2

<< "Klein over QQ, rank H_0: " << rank homKleinQQ_0 << endl;
<< "Klein over QQ, rank H_1: " << rank homKleinQQ_1 << endl;
<< "Klein over QQ, rank H_2: " << rank homKleinQQ_2 << endl;

<< "Klein over ZZ/2, rank H_0: " << rank homKleinZZ2_0 << endl;
<< "Klein over ZZ/2, rank H_1: " << rank homKleinZZ2_1 << endl;
<< "Klein over ZZ/2, rank H_2: " << rank homKleinZZ2_2 << endl;

